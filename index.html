<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<!--First page-->
			<!--Slide 1-->
			<section>
				<h1>Java 21 features presentation</h1>
			</section>

			<!--Core extensions-->
			<!--Slide 2-->
			<section data-auto-animate>
				<style>
					.fragment.blur {
						filter: blur(5px);
					}

					.fragment.blur.visible {
						filter: none;
					}
				</style>
				<h3>Core language extensions and updates</h3>
				<ul>
					<li class="fragment custom blur" data-fragment-index="1">
						<a href="https://openjdk.org/jeps/440">
							440: Record Patterns
						</a>
					</li>
					<li class="fragment custom blur">
						<a href="https://openjdk.org/jeps/441">
							441: Pattern Matching for switch
						</a>
					</li>
					<li class="fragment custom blur">
						<a href="https://openjdk.org/jeps/443">
							443: Unnamed Patterns and Variables (Preview)
						</a>
					</li>
					<li class="fragment custom blur">
						<a href=https://openjdk.org/jeps/431>
							431: Sequenced Collections
						</a>
					</li>
					<li class="fragment custom blur">
						<a href="https://openjdk.org/jeps/430">
							430: String Templates (Preview)
						</a>
					</li>
					<li class="fragment custom blur">
						<a href="https://openjdk.org/jeps/445">
							445: Unnamed Classes and Instance Main Methods (Preview)
						</a>
					</li>
				</ul>

				<aside class="notes">
					These are the speaker notes.
					They are only visible in a separate window after pressing the s key.
				</aside>
			</section>

			<!--Record Patterns selection 440-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<ul>
					<li class="fragment highlight-green">

						440: Record Patterns

					</li>
					<li>
						<a href="https://openjdk.org/jeps/441">
							441: Pattern Matching for switch
						</a>
					</li>
					<li>
						<a href="https://openjdk.org/jeps/443">
							443: Unnamed Patterns and Variables (Preview)
						</a>
					</li>
					<li>
						<a href=https://openjdk.org/jeps/431>
							431: Sequenced Collections
						</a>
					</li>
					<li>
						<a href="https://openjdk.org/jeps/430">
							430: String Templates (Preview)
						</a>
					</li>
					<li>
						<a href="https://openjdk.org/jeps/445">
							445: Unnamed Classes and Instance Main Methods (Preview)
						</a>
					</li>
				</ul>

				<aside class="notes">
					You can use a record pattern to test whether a value is an instance of a record class type (see
					Record Classes) and, if it is, to recursively perform pattern matching on its component values. The
					following example tests whether obj is an instance of the Point record with the record pattern
					Point(double x, double y);
				</aside>
			</section>



			<!--Record Patterns selection 440 ENHANCED -->
			<!--Slide 3-->
			<section style="font-size: 53%; ">
				<h3>Core language extensions and updates</h3>
				<ul style="color : green">
					<li>
						<a style="color : green" href="https://openjdk.org/jeps/440">
							440: Record Patterns
						</a>
						<ul>
							<li class="fragment" style="color : green">Pattern matching and records</li>
						</ul>
					</li>

					<pre style="width: 100%;" class="fragment java" data-id="code">
						<code  data-line-numbers="1-5|6-7|8-10|11-16|17-19|20-22|24-27" data-trim>
							// As of Java 16
							record Point(int x, int y) {}
							
							static void printSum(Object obj) {
								if (obj instanceof Point p) {
									int x = p.x();
									int y = p.y();
									System.out.println(x+y);
								}
							}
							// As of Java 21
							static void printSum(Object obj) {
								if (obj instanceof Point(int x, int y)) {
									System.out.println(x+y);
								}
							}
							// Requiring the full Records declaration for destructuring feels
							// like a chore. (line 13). The components must match, or the compiler won’t be happy:
							
							// Error:
							// incompatible types: pattern of type long is not applicable at int
							// if (obj instanceof Point(long x, int y)) {
							
							//Instead:	
							if (obj instanceof Point(var x, var y)) {
								// ...
							  }
					</code>
				</pre>

				</ul>
				<aside class="notes">

					<p>
						You can use a record pattern to test whether a value is an instance of a record class type (see
						Record Classes) and, if it is, to recursively perform pattern matching on its component values.
						The following example tests whether obj is an instance of the Point record with the record
						pattern Point(double x, double y):
					</p>

					<p>A record pattern consists of a type and a (possibly empty) record component pattern list. In this
						example, the type is Point and the component pattern list is (double x, double y).

					</p>
					<p> Point(int x, int y) is a rßthe pattern itself, and initializes those variables by invoking the
						accessor methods when a value is matched against the pattern. In effect, a record pattern
						disaggregates an instance of a record into its components. </p>

					<p>Well, in a certain sense, this way of thinking is correct. Repeating the Record’s definition to
						access its components seems tedious. But if we look further than such a simple example, the
						potential of what Record pattern matching can do for us will reveal itself!
						.</p>

				</aside>
			</section>

			<!--Record Patterns selection 440 Nested record patterns -->
			<!--Slide 3-->
			<section style="font-size: 70%; ">
				<h3>Core language extensions and updates</h3>
				<ul style="color : green; text-align: left">
					<li>
						<a style="color : green;" href="https://openjdk.org/jeps/440">
							440: Record Patterns
						</a>
						<ul>
							<li class="fragment" style="color : green">Nested record patterns
							</li>
						</ul>
					</li>
				</ul>
				<p class="fragment" style="size:10px; text-align: left;">Let’s design a Record representing a window
					frame, including its origin and size on
					the screen:
				</p>
				<pre style="width: 100%;" class="fragment java" data-id="code">
						<code  data-line-numbers="1-3|5-6|9-13|15-18" data-trim>
							record Size(int width, int height) { }
							record Point(int x, int y) { }
							record WindowFrame(Point origin, Size size) { }

							// To access the height component of a WindowFrame in 
							// the nested Size component, we’d need multiple matches:


							if (obj instanceof WindowFrame wf) {
								if (wf.size() != null) {
									System.out.println("Height: " + wf.size().height());
								}
							}

							//Java 21
							if (obj instanceof WindowFrame(Point origin, Size(int width, int height))) {
								System.out.println("Height: " + height);
							}
					</code>
				</pre>


				<aside class="notes">

					<p>
						Deconstructing a simple Record doesn’t have much of an advantage, in my opinion, at least
						without a feature I’m going to discuss shortly. The real power of deconstructing Records is
						found if a Record contains another Record.


					</p>
					<p>
						The difference here is that a simple WindowFrame(Point origin, Size size) matches even if Size
						size is null. When you deconstruct Size, too, though, it only matches if size isn’t null.

					</p>

				</aside>
			</section>


			<!--Record Patterns selection 441-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<ul>
					<li class="fragment strike">
						<a href="https://openjdk.org/jeps/440">
							440: Record Patterns
						</a>
					</li>
					<li class="fragment highlight-green">
						441: Pattern Matching for switch
					</li>
					<li>
						<a href="https://openjdk.org/jeps/443">
							443: Unnamed Patterns and Variables (Preview)
						</a>
					</li>
					<li>
						<a href=https://openjdk.org/jeps/431>
							431: Sequenced Collections
						</a>
					</li>
					<li>
						<a href="https://openjdk.org/jeps/430">
							430: String Templates (Preview)
						</a>
					</li>
					<li>
						<a href="https://openjdk.org/jeps/445">
							445: Unnamed Classes and Instance Main Methods (Preview)
						</a>
					</li>
				</ul>

				<aside class="notes">
					These are the speaker notes.
					They are only visible in a separate window after pressing the s key.
				</aside>
			</section>


			<!--441: Pattern Matching for Switch-->
			<!--Slide 3-->
			<section style="font-size: 56%; ">
				<h3>Core language extensions and updates</h3>
				<ul style="color : green">
					<li>
						<a class="fragment" style="color : green" href="https://openjdk.org/jeps/441">
							441: Pattern Matching for Switch
						</a>
					</li>
					<pre style="width: 100%;" class="fragment java" data-id="code">
						<code  data-line-numbers="1-5|7-10" data-trim>
							// BEFORE JAVA 16
							if (obj instanceof String) {
								String str = (String) obj;
								System.out.println(str);
							}
					
							// JAVA 16+
							if (obj instanceof String str) {
								System.out.println(str);
							}
					</code>
				</pre>
					<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-16|18-25"  class="java" data-trim>
						// BEFORE JAVA 21
						static String asStringValue (Object anyValue){
							String result = null;
				
							if (anyValue instanceof String str) {
								result = str;
							} else if (anyValue instanceof BigDecimal bd) {
								result = bd.toEngineeringString();
							} else if (anyValue instance Integer i){
								result = Integer.toString(i);
							} else{
								result = "n/a";
							}
				
							return result;
						}
				
						// JAVA 21+
						static String asStringValue (Object anyValue){
							return switch (anyValue) {
								case String str -> str;
								case BigDecimal bd -> bd.toEngineeringString();
								case Integer i -> Integer.toString(i);
								default -> "n/a";
							};
						}
					</code></pre>

				</ul>
				<aside class="notes">
					<p>In Java 16, JEP 394 extended the instanceof operator to take a type pattern and perform pattern
						matching. </p>

					<p>In the new code, obj matches the type pattern String s if, at run time, the value of obj is an
						instance of String. If the pattern matches then the instanceof expression is true and the
						pattern variable s is initialized to the value of obj cast to String, which can then be used in
						the contained block.</p>

					<p> Java 21 extended the concept to be usable in switch statements and expressions:</p>
				</aside>
			</section>

			<!--441: Pattern Matching for Switch | Switches and null-->
			<!--Slide 3-->
			<section style="font-size: 85%; ">
				<h3>Core language extensions and updates</h3>
				<ul style="color : green">
					<li>
						<a style="color : green" href="https://openjdk.org/jeps/440">
							441: Pattern Matching for Switch
						</a>
						<ul>
							<li class="fragment" style="color: white;">
								Switches and null
							</li>
						</ul>
					</li>
					<pre style="width: 100%;" class="fragment java" data-id="code">
						<code  data-line-numbers="1-6|7-11" data-trim>
							// Prior to Java 21
							static void testFooBarOld (String s){
								if (s == null) {
									System.out.println("Oops!");
									return;
								}
								switch (s) {
									case "Foo", "Bar" -> System.out.println("Great");
									default -> System.out.println("Ok");
								}
							}
					
					</code>
				</pre>
					<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-8"  class="java" data-trim>
						// As of Java 21
						static void testFooBarNew(String s) {
							switch (s) {
								case null         -> System.out.println("Oops");
								case "Foo", "Bar" -> System.out.println("Great");
								default           -> System.out.println("Ok");
							}
						}
					</code></pre>

				</ul>
				<aside class="notes">
					<p>Traditionally, switch statements and expressions throw NullPointerException if the selector
						expression evaluates to null, so testing for null must be done outside of the switch:</p>

					<p>This was reasonable when switch supported only a few reference types. However, if switch allows a
						selector expression of any reference type, and case labels can have type patterns, then the
						standalone null test feels like an arbitrary distinction which invites needless boilerplate and
						opportunities for error. It would be better to integrate the null test into the switch by
						allowing a new null case label:</p>

				</aside>
			</section>

			<!--443 Record Unnamed Patterns and Variables-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<ul>
					<li class="fragment strike highlight-red">
						440: Record Patterns
					</li>
					<li class="fragment strike highlight-red">
						441: Pattern Matching for switch
					</li>
					<li class="fragment highlight-green">
						443: Unnamed Patterns and Variables (Preview)
					</li>
					<li>
						<a href=https://openjdk.org/jeps/431>
							431: Sequenced Collections
						</a>
					</li>
					<li>
						<a href="https://openjdk.org/jeps/430">
							430: String Templates (Preview)
						</a>
					</li>
					<li>
						<a href="https://openjdk.org/jeps/445">
							445: Unnamed Classes and Instance Main Methods (Preview)
						</a>
					</li>
				</ul>

				<aside class="notes">
					These are the speaker notes.
					They are only visible in a separate window after pressing the s key.
				</aside>
			</section>


			<!--443: Unnamed Patterns and Variables (Preview)-->
			<!--Slide 3-->
			<section style="font-size: 85%; ">
				<h3>Core language extensions and updates</h3>
				<ul style="color : green">
					<li>
						<a style="color : green" href="https://openjdk.org/jeps/440">
							Unnamed Patterns and Variables (Preview)
						</a>
						<ul>
							<li>
								Unused variables
							</li>
						</ul>
					</li>
					<pre style="width: 100%;" class="fragment java" data-id="code">
						<code  data-line-numbers="3-6|9-11" data-trim>
							try {
								//...
							  } catch (Exception _) {
								// we don't need the actual exception
							  }
							  
							  int acc = 0;
							  for (Order _ : orders) {
								  if (acc < LIMIT) { 
									// the actual order is not used
								  }
							  }
					
					</code>
				</pre>
					<pre class="fragment" style="color: white;">Also:</pre>

					<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-4"  class="java" data-trim>
						// As of Java 21
						if (obj instanceof WindowFrame(_, Size(_, int height))) {
							System.out.println("Height: " + height);
						}
					</code></pre>

				</ul>
				<aside class="notes">
					<p>Another upcoming feature only available as a preview in Java 21 is JEP 443: Unnamed Patterns and
						Variables.
					</p>

					<p>This feature improves readability throughout our code by allowing us to replace an unused
						variable with _ (underscore). No more @SuppressWarnings("unused") needed to shut up all those
						pesky warnings!
					</p>

					<p>Nameless variables are quite useful in many scenarios, like the Exception variable in a catch
						block or side-effect-only constructs:
					</p>
					<p>
						Regarding Record pattern matching, this JEP simplifies (nested) calls as much as possible:
					</p>
				</aside>
			</section>


			<!--431 Sequenced Collections-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<ul>
					<li class="fragment strike highlight-red">
						440: Record Patterns
					</li>
					<li class="fragment strike highlight-red">
						441: Pattern Matching for switch
					</li>
					<li class="fragment strike highlight-red">
						443: Unnamed Patterns and Variables (Preview)
					</li>
					<li class="fragment highlight-green">
						431: Sequenced Collections
					</li>
					<li>
						<a href="https://openjdk.org/jeps/430">
							430: String Templates (Preview)
						</a>
					</li>
					<li>
						<a href="https://openjdk.org/jeps/445">
							445: Unnamed Classes and Instance Main Methods (Preview)
						</a>
					</li>
				</ul>

				<aside class="notes">
					<p>
						Dealing with Collections is improving with Java 21, as three new interfaces get retro-fitted
						right
						into the existing type hierarchies. These Sequenced Collections give us a uniform API to access
						the
						first and last elements, and process Collections in reverse.ß
						Dealing with Collections is improving with Java 21, as three new interfaces get retro-fitted
						right
						into the existing type hierarchies. These Sequenced Collections give us a uniform API to access
						the
						first and last elements, and process Collections in reverse.
					</p>
				</aside>
			</section>


			<!--431 Sequenced Collections | hierarchy-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<h4>Sequenced collections</h4>
				<img class="fragment" src="images/seq-col.png">

				<aside class="notes">
					<p>
						The three new sequenced interfaces are:
						<br />
						SequencedCollection<E> extends Collection<E>
								</br>
								SequencedSet<E> extends SequencedCollection<E>, Set<E>
											</br>
											SequencedMap<K, V> extends Map<K, V>

					</p>
				</aside>
			</section>

			<!--431 Sequenced Collections | Front to Back, Back to Front-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<h4>Sequenced collections</h4>
				<p class="fragment" style="text-align: left; font-size: 50%">It's common task with Collections is
					getting the first or
					last
					element
				</p>



				<pre style="width: 100%;" class="fragment java" data-id="code">
					<code  data-line-numbers="1-3" data-trim>
						List items = ...;
						String first = items.get(0);
						String last = items.get(items.size() - 1)
					 
				</code>
			</pre>

				<p class="fragment" style="text-align: left; font-size: 50%">
					And it's NOT pretty
				</p>

				<p class="fragment" style="text-align: left; font-size: 50%">
					Collection types supporting accessing the first and last element directly
				</p>


				<table class="fragment" style="font-size: 50%; text-align: left;">
					<thead>
						<tr>
							<th>Collection Type</th>
							<th>First Element</th>
							<th>Last Element</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><code>List</code></td>
							<td><code>list.get(0)</code></td>
							<td><code>list.get(list.size() - 1)</code></td>
						</tr>
						<tr>
							<td><code>Deque</code></td>
							<td><code>deque.getFirst()</code></td>
							<td><code>deque.getLast()</code></td>
						</tr>
						<tr>
							<td><code>SortedSet</code></td>
							<td><code>sortedSet.first()</code></td>
							<td><code>sortedSet.last()</code></td>
						</tr>
					</tbody>
				</table>

				<p class="fragment" style="text-align: left; font-size: 50%">
					For the inverse direction?
				</p>



				<aside class="notes">
					<p>
						Collection types supporting accessing the first and last element directly, but there’s no shared
						interface
						with a common API (yet):
					</p>
					<p>
						Every Collection-based type is easily traversable front to back, as it’s a descendant of
						Iterator. This way, we can use for-each loops, Stream pipelines, and create arrays from any
						collection by calling toArray(). For the inverse direction, back to front, there’s no easy way
						or trick available. That means, for example, that if we have to deal with a LinkedHashSet, we
						have to traverse the whole collection to get to the last element.

						Until Java 21 and Sequenced Collections!
					</p>
				</aside>
			</section>


			<!--431 Sequenced Collections | Sequenced set and collection -->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<h4>Sequenced collections</h4>

				<pre style="width: 100%;" class="fragment java" data-id="code">
					<code  data-line-numbers="2-3|5-7|9-13" data-trim>
						interface SequencedCollection extends Collection {
							// NEW METHOD
							SequencedCollection reversed();
			
							// PROMOTED METHODS FROM Deque
							void addFirst(E);
							void addLast(E);
						
							E getFirst();
							E getLast();
						
							E removeFirst();
							E removeLast();
						}
					 
				</code>
			</pre>

				<pre style="width: 100%; height: 2100%;" class="fragment java fade" data-id="code">
				<code  data-line-numbers="1-3" data-trim>
					interface SequencedSet extends Set, SequencedCollection {
						SequencedSet reversed();    // covariant override
					}
				 
			</code>
		</pre>
				<aside class="notes">
					<p>
						A SequencedCollection has first and last elements with the elements between them having
						successors and predecessors. A SequencedCollection supports common operations at either end, and
						it supports processing the elements from first to last and from last to first (such as, forward
						and reverse).

						The reversed() method provides a reverse-ordered view of the original collection. Any
						modifications to the original collection are visible in the view.


					</p>
					<p>
						The add*(E) and remove*() methods are optional, primarily to support the case of unmodifiable
						collections. The get*() and remove*() methods throw a NoSuchElementException if the collection
						is empty. There are no definitions of equals() and hashCode() in SequencedCollection because its
						subinterfaces have conflicting definitions. </p>
					<p>
						A SequencedSet is both a SequencedCollection and a Set.

						A SequencedSet can be thought of either as a Set that also has a well-defined encounter order,
						or as a SequencedCollection that also has unique elements.

						This interface has the same requirements on the equals and hashCode methods as defined by
						Set.equals and Set.hashCode. A Set and a SequencedSet compare equals if and only if they have
						equal elements, irrespective of ordering.

						SequencedSet defines the reversed() method, which provides a reverse-ordered view of this set.
						The only difference from the SequencedCollection.reversed method is that the return type of
						SequencedSet.reversed is SequencedSet.
					</p>
				</aside>
			</section>

			<!--431 Sequenced Collections | Sequenced Map-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<h4>Sequenced collections</h4>

				<pre style="width: 100%;" class="fragment java" data-id="code">
					<code  data-line-numbers="2|3-5|6-7|8-13" data-trim>
						interface SequencedMap&lt;K,V&gt; extends Map&lt;K,V&gt;  {
							SequencedMap&lt;K,V&gt; reversed();
							SequencedSet&lt;K&gt; sequencedKeySet();
							SequencedCollection&lt;V&gt;sequencedValues();
							SequencedSet&lt;&lt;K,V&gt;&gt; sequencedEntrySet();
							V putFirst(K, V);
							V putLast(K, V);
							// methods promoted from NavigableMap
							Entry&lt;K,V&gt;firstEntry();
							Entry&lt;K,V&gt;lastEntry();
							Entry&lt;K,V&gt;pollFirstEntry();
							Entry&lt;K,V&gt; pollLastEntry();
						}
					 
				</code>
			</pre>

				<aside class="notes">
					<p>A SequencedMap provides methods to add mappings, to retrieve mappings, and to remove mappings at
						either end of the map's encounter order. This interface also defines the reversed() method,
						which
						provides a reverse-ordered view of this map.
					</p>

					<p>A SequencedMap has a well-defined encounter order that supports operations at both ends and is
						reversible. A map's reverse-ordered view is generally not serializable, even if the original map
						is
						serializable. The encounter order of a SequencedMap is similar to that of the elements of a
						SequencedCollection, but the ordering applies to mappings instead of individual elements:
					</p>
					<p>The sequencedKeySet(), sequencedValues(), and sequencedEntrySet()methods are exactly analogous to
						the keySet(), values(), and entrySet() methods of Map interface. All of these methods return
						views
						of the underlying collection; where modifications to the view are visible in the underlying
						collection and vice versa. The encounter order of these views exactly corresponds to the
						encounter
						order of the underlying map.
					</p>

				</aside>
			</section>


			<!--431 String Templates-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<ul>
					<li class="fragment strike highlight-red">
						440: Record Patterns
					</li>
					<li class="fragment strike highlight-red">
						441: Pattern Matching for switch
					</li>
					<li class="fragment strike highlight-red">
						443: Unnamed Patterns and Variables (Preview)
					</li>
					<li class="fragment strike highlight-red">
						431: Sequenced Collections
					</li>
					<li class="fragment  highlight-green">
						430: String Templates (Preview)

					</li>
					<li>
						<a href="https://openjdk.org/jeps/445">
							445: Unnamed Classes and Instance Main Methods (Preview)
						</a>
					</li>
				</ul>

				<aside class="notes">
					<p>
						String templates are a preview feature in JDK 21 and complement the string literals and text
						blocks that already exist in Java. To produce specialized results, string templates mix literal
						text (string literals or text blocks) with embedded expressions that are handled by template
						processors.

						The new language feature and API make it easier to create non-string values that are computed at
						runtime using literal text and embedded expressions.
					</p>
				</aside>
			</section>


			<!--431: String Templates examples -->
			<!--Slide 3-->
			<section style="font-size: 85%; ">
				<h3>Core language extensions and updates</h3>
				<h4>String templates</h4>


				<p class="fragment" style="text-align: left; font-size: 70%">
					Mechanisms and types that work with String
					literals and instances built right into the language/JDK to that:

				</p>


				<ul class="fragment" style="text-align: left; font-size: 70%; text-align: left;">
					<li>The <code>+</code> (plus) operator</li>
					<li><code>StringBuffer</code> and <code>StringBuilder</code></li>
					<li><code>String::format</code> and <code>String::formatted</code></li>
					<li><code>java.text.MessageFormat</code></li>
				</ul>


				<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1|2|3|4|5|6|7-8"  class="java" data-trim>
					// As of Java 21
					//The create a template expression, we need two things:
					//A template processor
					//A template containing wrapped expressions like \{name}
					var name = "Ben";
					var tempC = 28;
			
					var greeting = STR."Hello \{this.user.firstname()}, how are you?\nIt's \{tempC}°C today!";
			
					</code></pre>

				</ul>
				<p class="fragment" style="text-align: left; font-size: 70%">
					The first question you might have is: where does STR come from?
				</p>

				<p class="fragment" style="text-align: left; font-size: 70%">As String -> String templates are most
					likely the default use case for String templates, the template
					processor STR is automagically imported into every Java source file. So all the inconvenience added
					by
					Java’s approach is 4 additional characters.
				</p>

				<aside class="notes">
					<p>The new way to work with Strings in Java is called template expression, a programmable way of
						safely interpolating expressions in String literals. And even better than just interpolating, we
						can turn structured text into any object, not just a String.

					</p>
				</aside>
			</section>

			<!--431: String Templates multiline templates -->
			<!--Slide 3-->
			<section style="font-size: 85%; ">
				<h3>Core language extensions and updates</h3>
				<h4>String templates</h4>


				<p class="fragment" style="text-align: left; font-size: 70%">
					Multi-Line Templates and Expressions
				</p>

				<pre style="width: 100%;font-size: 40%;" class="fragment" data-id="code"><code data-line-numbers="1-12|13|14-22"  class="java" data-trim>
					// As of Java 21

					String customerName    = "Java Duke";
					String phone           = "555-123-4567";
					String address         = "1 Maple Drive, Anytown";
					String json = STR."""
					{
						"name":    "\{customerName}",
						"phone":   "\{phone}",
						"address": "\{address}"
					}
					""";
					// Not only the template itself can be multi-line, expressions can be too, including comments!
					var json = STR."""
					{
					  "user": "\{
						// We only want to use the firstname
						this.user.firstname()
					  }",
					  "temperatureCelsius: \{tempC}
					}
					""";
			
					</code></pre>

				<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-3|4|5"  class="java" data-trim>
						//Embedded expressions can perform arithmetic operations.
						double x = 10.5, y = 20.6;
						String p = STR."\{x} * \{y} = \{x * y}";
						System.out.println(p);
						// Output: 10.5 * 20.6 = 216.3
						</code></pre>


				<aside class="notes">
					<p>The template processor STR is one of the template processors that's included in the JDK. It
						automatically performs string interpolation by replacing each embedded expression in the
						template with its value, converted to a string. The JDK includes two other template processors:
					</p>
					<p>
						The FMT Template Processor: It's like the STR template processor except that it accepts format
						specifiers as defined in java.util.Formatter and locale information in a similar way as in
						printf method invocations.
					</p>
					<p>
						The RAW Template Processor: It doesn't automatically process the string template like the STR
						template processors. You can use it to help you create your own template processors. Note that
						you can also implement the StringTemplate.Processor interface to create a template processor.
						See Creating a Template Processor.
					</p>
					<p>
						The main advantage of Java’s implementation over other languages in my opinion is the
						possibility of using another template processor than a String -> String one. Look at the JSON
						example, again. You can write your own processor and return JSONObject instead of String
					</p>
				</aside>
			</section>

			<!--445  Unnamed Classes-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<ul>
					<li class="fragment strike highlight-red">
						440: Record Patterns
					</li>
					<li class="fragment strike highlight-red">
						441: Pattern Matching for switch
					</li>
					<li class="fragment strike highlight-red">
						443: Unnamed Patterns and Variables (Preview)
					</li>
					<li class="fragment strike highlight-red">
						431: Sequenced Collections
					</li>
					<li class="fragment strike highlight-red">
						430: String Templates (Preview)

					</li>
					<li class="fragment highlight-green">
						445: Unnamed Classes and Instance Main Methods (Preview)
					</li>
				</ul>

				<aside class="notes">
					<p>
						Even though Java is an excellent language for complex, large, enterprise-grade multi-developer
						applications, it’s still intended to be a first programming language, too. That’s why the
						initial hurdles should be as low as possible.

						Let’s take a look at how to write your first Java program.


					</p>
				</aside>
			</section>

			<!--431:  Unnamed Classes Simpler Main Methods-->
			<!--Slide 3-->
			<section style="font-size: 85%; ">
				<h3>Core language extensions and updates</h3>
				<h4>Simpler Main Methods </h4>


				<p class="fragment" style="text-align: left; font-size: 70%">
					Let’s take a look at how to write your first Java program.
				</p>


				<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1|2|3|4|5|6|7-8"  class="java" data-trim>
					package com.beliefdrivendesign;

					public class MyAwesomeApp {
					
					  public static void main(String... args) {
						// Awesome code goes here
					  }
					}
					</code></pre>


				<p class="fragment" style="text-align: left; font-size: 70%">
					Less is More
				</p>
				<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-6"  class="java" data-trim>
					class MyAwesomeApp {

						void main() {
						  // Awesome code goes here
						}
					  }
					</code></pre>

				<p class="fragment" style="text-align: left; font-size: 70%">
					This means we can write more than main() method in a class. The Java compiler will search the main()
					method in the following sequence. Whatever the JVM finds the first main() method in the sequence, it
					will use it to launch the program:

				</p>

				<ul class="fragment" style="font-size: 50%;">
					<li>A <code>static void main(String[] args)</code> method</li>
					<li>A <code>static void main()</code> method without any arguments</li>
					<li>A <code>void main(String[] args)</code> instance method without <code>static</code> keyword</li>
					<li>A <code>void main()</code> instance method without <code>static</code> keyword and arguments
					</li>
				</ul>

				<aside class="notes">
					<p>A package declaration, which might be there, maybe not.
					</p>
					<p>The class declaration uses a mandatory visibility modifier (public) that doesn’t make sense for
						our first program. And if you name the file containing it not the same as the class, it won’t
						compile.
					</p>
					<p>
						Next, there’s a method aptly named main, so it’s the actual entry point. However, it uses a
						visibility modifier (public), too, but adds in a lifetime/access modifier (static) for good
						measure. To make it even more complicated, let’s introduce var-args (String...) or an array
						(String[]) right in your first program.
					</p>
					<p>Note that, in all above cases, the method must be non-private i.e. it must have access modifier
						either public, protected or package.

						For example, in the following program, we have created two main methods.</p>
				</aside>
			</section>

			<!--431:  Unnamed Classes Simpler Main part 2-->
			<!--Slide 3-->
			<section style="font-size: 85%; ">
				<h3>Core language extensions and updates</h3>
				<h4>Simpler Main Methods </h4>

				<p class="fragment" style="text-align: left; font-size: 70%">
					For example, in the following program, we have created two main methods.
				</p>

				<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-8"  class="java" data-trim>
					//An Unnamed Class with Two main() Methods
					void main(String[] args) {
					  System.out.println("Main method with args");
					}
					
					void main() {
					  System.out.println("Main method without args");
					}
					</code></pre>

				<p class="fragment" style="text-align: left; font-size: 70%">
					In the sequence, the void main(String[] args) comes before the void main(), so the program output
					will be:
				</p>

				<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-6"  class="java" data-trim>
					Main method with args

					</code></pre>

				<aside class="notes">
					<p>
						Note that the above instance main() methods can be written with normal classes also. The
						following Java program is a valid program and it will execute the main() method.
					</p>
				</aside>
			</section>

			<!--431:  Unnamed Classes  Rules to Create and Use an Unnamed Class-->
			<!--Slide 3-->
			<section style="font-size: 85%; ">
				<h3>Core language extensions and updates</h3>
				<h4> Rules to Create and Use an Unnamed Class</h4>

				<p class="fragment" style="text-align: left; font-size: 70%">
					There are certain rules to abide by to create the unnamed classes correctly. Let us check them out.
				</p>

				<p class="fragment" style="text-align: left; font-size: 70%">
					As the class has no name, we can’t reference or instantiate it any way ourselves. It resides in the
					unnamed package in the unnamed module. Besides that, it behaves almost like a “normal” class
					declaration. We can’t use certain features, though, like implementing an interface, extending
					another type, referencing the class by name, generating documentation with javadoc, etc.


				</p>



				<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-8"  class="java" data-trim>
					void main() {
						// Awesome code goes here
					  }
					</code></pre>

				<p class="fragment" style="text-align: left; font-size: 70%">

					This is preview language feature, disabled by default
				</p>
				<p class="fragment" style="text-align: left; font-size: 70%">
					Do you want to use this Preview Feature?
				</p>


				<pre style="width: 100%;" class="fragment" data-id="code"><code data-line-numbers="1-6"  class="java" data-trim>
					# COMPILE
					javac --release 21 --enable-preview MyAwesomeApp.java
					
					# RUN
					java --enable-preview MyAwesomeApp
					</code></pre>

				<aside class="notes">

					<p>
						An unnamed class is always a member of the unnamed package. It is also final and cannot
						implement any interface nor extend any class other than Object. An unnamed class cannot be
						referenced by name, so there can be no method references to its static methods; the this keyword
						can still be used, however, and so can method references to instance methods.

					</p>
					<p>
						An unnamed class resides in the unnamed package, and the unnamed package resides in the unnamed
						module. While there can be only one unnamed package (barring multiple class loaders) and only
						one unnamed module, there can be multiple unnamed classes in the unnamed module. Every unnamed
						class contains a main method and so represents a program, thus multiple such classes in the
						unnamed package represent multiple programs.


					</p>
					<p>
						The way Java projects are structured is simple: every class is in a package and every package is
						in a module. This method of namespacing and compartmentalizing your code is prevalent in many
						programming languages and a necessity for any program consisting of more than a few classes.
						However, just like public static void main(String... args) method in the previous section, it’s
						another hurdle for simple, one-class programs.

					</p>
				</aside>
			</section>


			<!--445  Core Concepts finished-->
			<!--Slide 3-->
			<section>
				<h3>Core language extensions and updates</h3>
				<ul>
					<li class="fragment strike highlight-red">
						440: Record Patterns
					</li>
					<li class="fragment strike highlight-red">
						441: Pattern Matching for switch
					</li>
					<li class="fragment strike highlight-red">
						443: Unnamed Patterns and Variables (Preview)
					</li>
					<li class="fragment strike highlight-red">
						431: Sequenced Collections
					</li>
					<li class="fragment strike highlight-red">
						430: String Templates (Preview)

					</li>
					<li class="fragment strike highlight-red">
						445: Unnamed Classes and Instance Main Methods (Preview)
					</li>
				</ul>

				<aside class="notes">
					<p>
						So we covered basic core functionalities, let's go to performancw and infrascructure
						improvements
					</p>
				</aside>
			</section>

			<!--Performance improvements-->
			<section>

				<h3>Performance and infrastructure improvements</h3>
				<ul>
					<li class="fragment fade"><a href="#439-generational-zgchttpsopenjdkorgjeps439">439: Generational
							ZGC</a></li>
					<li class="fragment fade"><a
							href="#442-foreign-function--memory-api-3rd-previewhttpsopenjdkorgjeps442">442: Foreign
							Function &amp; Memory API (Third Preview)</a></li>
				</ul>

				<aside class="notes">
					The Z Garbage Collector, often shortened to ZGC, received a significant update in JDK 21. ZGC is now
					a multi-generational garbage collector, typically called Generational ZGC or GenZGC. Let’s take a
					look at this update to ZGC!
				</aside>
			</section>

			<!--Generational ZGC-->
			<section>
				<h3>Performance and infrastructure improvements</h3>
				<h4>Generational ZGC</h4>

				<p class="fragment" style="text-align: left; font-size: 70%">
					The following advantages of generational ZGC add up to a more productive environment for Java
					applications:

				</p>
				<ul class="fragment" style="text-align: left; font-size: 65%">
					<li value="1"><b><strong>Less Interruptions</strong></b><span>: Your program will run much more
							continuously thanks to these improved memory management strategies. </span></li>
					<li value="2"><b><strong>Effective Memory Use</strong></b><span>: Generational ZGC reduces memory
							use, freeing up RAM for additional crucial tasks. </span></li>
					<li value="3"><b><strong>Reduced CPU Burden</strong></b><span>: Generational ZGC lightens the load
							on your computer’s central processing unit (CPU).</span></li>
				</ul>
				<p class="fragment" style="text-align: left; font-size: 55%">
					However, there are certain disadvantages to Generational ZGC as well, such as:
				</p>
				<ul class="fragment" style="text-align: left; font-size: 65%">
					<li value="1"><b><strong>Added complexity</strong></b><span>: Compared to non-generational ZGC,
							generational ZGC is a more complicated garbage collector. This may make problem-solving and
							debugging more challenging.</span></li>
					<li value="2"><b><strong>Impact on performance for specific workloads</strong></b><span>: Not every
							workload is a good fit for generational ZGC. Applications that often allocate and deallocate
							objects, for instance, could see a decrease in performance while using Generational
							ZGC.</span></li>
				</ul>

				<aside class="notes">

					<p>(READ THESE FIRST)
						When ZGC was initially released, it was a single-generation garbage collector. Starting with JDK
						21, and in addition to single-generation, multi-generation support is now also available in ZGC.
						To use GenZGC requires passing two VM arguments:

						ZGC does the majority of its work while application threads are running, pausing those threads
						only briefly. ZGC's pause times are consistently measured in microseconds; by contrast the pause
						times of the default garbage collector, G1, range from milliseconds to seconds. ZGC's low pause
						times are independent of heap size: Workloads can use heap sizes from a few hundred megabytes
						all the way up to multiple terabytes and still enjoy low pause times.

						For many workloads, simply using ZGC is enough to solve all latency problems related to garbage
						collection. This works well as long as there are sufficient resources (i.e., memory and CPU)
						available to ensure that ZGC can reclaim memory faster than the concurrently-running application
						threads consume it. However, the problem is ZGC currently stores all objects together,
						regardless of age, so it
						must collect all objects every time it runs.
					</p>
					<p>
						young objects tend to die young, while old objects tend to stick around. Thus collecting young
						objects requires fewer resources and produces more memory, while collecting old objects requires
						more resources and priduces less memory. We can thus improve the performance of applications
						that
						use ZGC by collecting young objects more frequently.
					</p>
					<p>
						Generational ZGC recognizes that not every object in a Java application ages at the same time.
						The
						heap is divided into two logical generations by the new generational ZGC: the old generation
						consists of objects that have been allocated recently and the young generation of objects that
						have
						been around for a long time. In order to allow ZGC to concentrate on gathering the lucrative
						young
						objects, each generation is collected separately from the others.
					</p>


				</aside>
			</section>

			<!--442: Foreign Function & Memory API-->
			<section>

				<h3>Performance and infrastructure improvements</h3>
				<ul>
					<li class="fragment strike highlight-red">439: Generational
						ZGC</li>
					<li class="fragment highlight-green">442: Foreign
						Function &amp; Memory API (Third Preview)
					</li>
				</ul>

				<aside class="notes">
					The Z Garbage Collector, often shortened to ZGC, received a significant update in JDK 21. ZGC is now
					a multi-generational garbage collector, typically called Generational ZGC or GenZGC. Let’s take a
					look at this update to ZGC!
				</aside>
			</section>

			<!--442: Foreign Function & Memory API extended-->
			<section>
				<h3>Performance and infrastructure improvements</h3>
				<h4>442: Foreign Function & Memory API (Third Preview) </h4>

				<p class="fragment" style="text-align: left; font-size: 70%">
					The Foreign Function & Memory API was first previewed in JDK 19, then in JDK 20
				</p>
				<p class="fragment" style="text-align: left; font-size: 70%">
					The Foreign Function & Memory API enables Java applications to call native libraries and process
					native data by invoking foreign functions and safely accessing foreign memory (e.g. outside JVM).
					I am looking forward to the first non-preview version of this feature in future Java releases!
					It's still preview and targeted for JDK 22

				</p>


				<aside class="notes">

					<p>(READ THESE FIRST)
						This new API improves the the ability to exchange and make use of informationof Java programs
						with code and data outside the Java
						runtime without relying on the Java Native Interface (JNI). As you remember the log4j scandal
						happened. It aims to replace JNI altogether
						with a solution that’s easier to use, safer, and offers higher performance while providing
						generality by enabling apps to operate on different kinds of foreign memory.
					</p>

					<p>
						The API is expected to revolutionize how Java interacts with native libraries, and it aligns
						with the broader Java roadmap that aims to make the platform safer and more efficient
						out-of-the-box. For developers working with Java and native libraries, this is an exciting
						development that promises to simplify complexities while ensuring safer and more efficient code.


					</p>
				</aside>
			</section>


			<!--Extensions to Multi-threaded code-->
			<!--Slide 4-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<ul>
					<li class="fragment">444: Virtual Threads</li>
					<li class="fragment">446: Scoped Values (Preview)</li>
					<li class="fragment">453: Structured Concurrency (Preview)</li>
				</ul>
				<aside class="notes">
					These are the speaker notes.
					They are only visible in a separate window after pressing the s key.
				</aside>
			</section>

			<!--Extensions to Multi-threaded code highlist virtual threads-->
			<!--Slide 4-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<ul>
					<li class="fragment highlight-green">444: Virtual Threads</a></li>
					<li class="">446: Scoped Values (Preview)</li>
					<li class="">453: Structured Concurrency (Preview)</li>
				</ul>
				<aside class="notes">
					<p>A preview feature in JDKs 19 and 20, virtual threads have now been finalized and made it into JDK
						21 as a new feature.


					</p>

				</aside>
			</section>

			<!--Virtual Threads first image-->
			<!--Slide 5-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<h4>444: Virtual Threads</h4>
				<img class="fragment" src="images/virtual-1.png"></img>

				<p></p>
				<aside class="notes">
					<p>
						so on the left here we have a browser a client is making a call to an application and this
						application for our example is written in Java and spring in normal spring MVC applications we
						may do things like read or persist from a database using something like jdbc or jpa we may use
						an input stream to write to a file we may communicate over HTTP to talk to another service this
						could be a public API this could be another service in our microservice architecture or it might
						be communicating to message Brokers.
					</p>
					<p>these are all blocking apis</p>
					<p>
						so this is where virtual threads
						make sense, this application that we've been working on works great on our laptop,
						and even in the initial stages of implementation,
						<br /><br />
						however once you start experiencing a high volume of traffic, it is causing it to crash.
					</p>
					<p>why is this happening ? what can we do to prevent this? </p>

					<p>This is because of the thread per request us model
					</p>
				</aside>
			</section>

			<!--Virtual Threads second image-->
			<!--Slide 5-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<h4>444: Virtual Threads</h4>
				<img class="fragment" src="images/virtual-2.png"></img>

				<p></p>
				<aside class="notes">
					<p>
						so again we have a client that makes a request over to our server, when that request is
						happening the server will go ahead, let's say in the instance of talking to a database via jdbc,
						jpa.
						<br /><br />

						when we make this request, the thread , the operating system thread, the Java thread -that is
						tied to the operating system thread is going to be in use.
						<br />
						<br />

						because we are talking to a database, this is a blocking operation.
						<br />
						<br />

						so while that thread is in use, nothing else can use it.
						<br />
						<br />

						And as you can see as our application grows and we need another thread to maybe talk to another
						database , or we need a thread to make a call to another service, these are all threads being
						tied up in our system.
						<br />
						<br />

						The important part here is that there is a maximum number of concurrent threads that are
						allowed.
						<br />
						<br />

						this is based on your Hardware, the system, Etc .
						<br />
						<br />

						when the number of Maximum threads has been reached , each subsequent request will need to wait
						for a thread to be released to fulfill that request .
						<br />
						<br />

						that is why when we experience that high throughput, we can see some slowness in an application
						, we can even see some 500 errors , because it can't fulfill that request
						<br />
						<br />

						so that is thread per request kind of in a nutshell right.
						<br />
						<br />


					</p>
				</aside>
			</section>


			<!--Virtual Threads third image-->
			<!--Slide 5-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<h4>444: Virtual Threads</h4>
				<img class="fragment" src="images/virtual-3.png"></img>

				<p></p>
				<aside class="notes">
					<p>
						And the reason that happens is because Java is made of threads,
						<br />
						<br />

						when you create a new thread in Java it is tied to the operating system threads, this means that
						we have a finite pool of threads that we can take advantage of
						<br />
						<br />

						we just saw what would happen in that scenario
						<br /><br />
						so how can we solve for this currently in our applications ?
					</p>
				</aside>
			</section>

			<!--Virtual Threads fourth image-->
			<!--Slide 5-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<h4>444: Virtual Threads</h4>
				<img class="fragment" src="images/virtual-4.png"></img>

				<p></p>
				<aside class="notes">
					<p>
						when we talk about scalability Solutions, we have one way that we can solve for this.
						<br /><br />
						which is addressing this using more Hardware so we could scale vertically, adding more memory or
						CPU. we can scale horizontally adding more servers
						<br /><br />

						another approach to this is asynchronous programming, we can solve this by writing non-blocking
						software, and like any architecture Choice, there are pros and cons to each.

						<br /><br />
						btw, besides learning curve those Frameworks come at a very significant cost.
						The programming model is awful, they're
						hard to debug stack traces are incomprehensible, but we have something better
						<br /><br />
						knowing all these how we can solve it ?
					</p>
				</aside>
			</section>

			<!--Virtual Threads fifth image-->
			<!--Slide 5-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<h4>444: Virtual Threads</h4>
				<img class="fragment" src="images/virtual-5.png"></img>

				<p></p>
				<aside class="notes">
					<p>
						Java introduced virtual threads this is in JDK 19 and 20 as a preview release, and as we know
						it's already inside jdk 21
						<br /><br />
						but what this does is it, allows us to create these virtual threads shown by the V here, and
						all these virtual threads are really lightweight and inexpensive and easy to create
						<br /><br />

						And these are tied to a platform thread, that is tied to the operating system thread.
						<br /><br />

						so no longer are we tying up platform threads that are tied to that operating system threadm
						we're just using these lightweight virtual threads all over the place
						<br /><br />

						so this is going to help us with high throughput servers with simple thread per request code
						code ,using the same apis
						<br /><br />

						and I think what's really really exciting about this we can do this we can take advantage of
						virtual threads with little or no code changes in our spring applications.
					</p>
				</aside>
			</section>

			<!--Virtual Threads sixth image-->
			<!--Slide 5-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<h4>444: Virtual Threads</h4>
				<img class="fragment" src="images/virtual-6.jpeg"></img>

				<aside class="notes">
					<p>
						Also virtual threads are real threads but they're much lighter weight, because they don't drag
						around these huge megabyte scale data structures.
						<br /><br />

						They store their threads thread Stacks as delimited continuations in the garbage collected Heap.
						<br /><br />

						So when you when you start a virtual thread , you're paying maybe a couple hundred bytes 
						<br/><br/>
						And virtual threads can scale to like a million concurrent connections on a laptop like this one
						<br /><br />

						but i need to note this that they're not some other kind of weird abstraction, they're real threads,they Implement
						Java.Lang.thread, they support thread local
						<br /><br />

						all your thread code just runs, you get clean stack traces, you get clean thread dumps, you get
						debugging and profiling

						<br /><br />
						the the point of this is not to make your application go faster virtual threads won't make your
						threads go your your code go faster but it will make it scale better
					</p>
				</aside>
			</section>

						<!--Virtual Threads sixth image-->
			<!--Slide 5-->
			<section>
				<p>Demo</p>
				<aside class="notes">
					<p>
					Show the demo						
					</p>
				</aside>
			</section>

			<!--Extensions to Multi-threaded code highlist virtual threads-->
			<!--Slide 4-->
			<section>
				<h3>Extensions to multi-threaded code</h3>
				<ul>
					<li class="fragment strike highlight-red">444: Virtual Threads</a></li>
					<li class="fragment highlight-green">446: Scoped Values (Preview)</li>
					<li class="">453: Structured Concurrency (Preview)</li>
				</ul>
				<aside class="notes">
					<p>A preview feature in JDKs 19 and 20, virtual threads have now been finalized and made it into JDK
						21 as a new feature.


					</p>

				</aside>
			</section>





			<!---->
			<section style="font-size: 30px; margin:0px">
				<p>some gtexts</p>
				<pre data-id="code"><code data-line-numbers class="java" data-trim>
					private int[] findSubArray(int[] array, int targetSum) {
						int sum = 0;
						int start = 0;
				
						for (int i = 0; i <= array.length; i++) {
							while (sum > targetSum && start < i - 1) {
								sum = sum - array[start];
								start++;
							}
							if (sum == targetSum) {
								System.out.println("bingo");
							}
							if (i < array.length) {
								sum = sum + array[i];
							}
						}
						return null;
					}
					
				</code></pre>
			</section>
			<section>

			</section>


		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>